<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习笔记 on JadeRong</title>
    <link>https://rrrwx.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 学习笔记 on JadeRong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 May 2020 18:19:52 +0800</lastBuildDate>
    
	<atom:link href="https://rrrwx.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JDBC之连接池</title>
      <link>https://rrrwx.github.io/2020/jdbc%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Fri, 22 May 2020 18:19:52 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jdbc%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
https://www.cnblogs.com/zzsuje/articles/10444032.html
数据库连接池  数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；
释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。
   对于大多数应用程序，当它们正在处理事务时，仅需要能够访问JDBC连接的 1 个线程。当不处理事务时，这个连接就会闲置（造成资源的浪费）。相反，连接池允许闲置的连接被其它需要的线程使用。 当一个线程需要用 JDBC 对一个 数据库操作时，它从池中请求一个连接。当这个线程使用完了这个连接，将它返回到连接池中（连接池会自动收回连接，当然我们也可以在用完以后释放），这样这就可以被其它想使用它的线程使用，这样不会照成内存的浪费。 当连接被从池中调用出来，那么这个连接将被这个线程专有地使用。    数据库连接池的主要操作如下：
（1）建立数据库连接池对象（服务器启动）；
（2）按照事先指定的参数创建初始数量的数据库连接（即：空闲连接数）,我们在安装数据库的时候就可以指定；
（3）对于一个数据库访问请求，直接从连接池中得到一个连接。如果数据库连接池对象中没有空闲的连接，且连接数没有达到最大（即：最大活跃连接数），创建一个新的数据库连接。而如果连接数达到最大，就会再创建事先定好的连接数；
（4）对数据库进行存取操作；
（5）关闭数据库，释放所有数据库连接（此时的关闭数据库连接，并非真正关闭，而是将其放入空闲队列中。如实际空闲连接 数大于初始空闲连接数则释放连接）；
（6）释放数据库连接池对象（服务器停止、维护期间，释放数据库连接池对象，并释放所有连接）。
 常见的数据库连接池有dbcp、c3p0
注：连接池返回的Connection对象，它的close()方法不是关闭连接，而是把连接归还给连接池
dbcp  DBCP（DataBase Connection Pool）数据库连接池，是java数据库连接池的一种，由Apache开发，通过数据库连接池，可以让程序自动管理数据库连接的释放和断开。 使用javax.sql.DateSource接口 也可以使用配置文件，把连接参数和连接池初始化参数都写进配置文件。  //需要先导入apache的commons.dbcp包 import org.apache.commons.dbcp.BasicDateSource ; public class dbcpDemo { public void connect() throws Exception { /* * 1. 创建来连接池对象 * 2. 配置四大参数 * 3. 配置连接池参数 * 4. 获取连接对象 */ //BasicDataSource类实现了DataSource接口  BasicDataSource dataSource = new BasicDataSource() ; //手动配置连接参数  dataSource.</description>
    </item>
    
    <item>
      <title>JDBC之事务</title>
      <link>https://rrrwx.github.io/2020/jdbc%E4%B9%8B%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Fri, 22 May 2020 15:08:30 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jdbc%E4%B9%8B%E4%BA%8B%E5%8A%A1/</guid>
      <description>https://www.runoob.com/mysql/mysql-transaction.html
https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
http://blog.sina.com.cn/s/blog_4aefad88010092uc.html
MySQL事务  MySQL 事务(transaction)主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你既需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！
 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。 事务用来管理 insert,update,delete 语句。   （一）事务的四大特性（ACID）  原子性(Atomicity)： 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样； 一致性(Consistency)： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作； 隔离性(Isolation)： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）； 持久性(Durability)： 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。  （二）并发问题 数据库肯定是要被广大客户所共享访问的，那么在数据库操作过程中很可能出现以下几种不确定情况。
 更新丢失（Lost update）： 两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。 脏读取（Dirty Reads）： 一个事务开始读取了某行数据，但是另外一个事务已经更新了此数据但没有能够及时提交。这是相当危险的，因为很可能所有的操作都被回滚。（最重要的） 不可重复读取（Non-repeatable Reads）： 一个事务对同一行数据重复读取两次，但是却得到了不同的结果。例如，在两次读取的中途，有另外一个事务对该行数据进行了修改，并提交。这里两个并发事务读写同一个行记录。 两次更新问题（Second lost updates problem）： 无法重复读取的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。 虚读（Phantom Reads）： 事务在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据（这里并不要求两次查询的SQL语句相同）。这是因为在两次查询过程中有另外一个事务插入数据造成的。注意这里是两个并发事务操作的不是同一个行记录。  （三）事务隔离级别 为了避免上面出现的几种情况，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。
 未授权读取（Read Uncommitted）： 允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。在多个事务之间使用它将会是非常危险的，事务的回滚操作或失败将会影响到其他并发事务。 授权读取（Read Committed）： 允许不可重复读取，但不允许脏读取。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。 可重复读取（Repeatable Read）： 禁止不可重复读取和脏读取，但是有时可能出现幻影数据。这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。 序列化（Serializable）： 提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。  从上到下隔离级别依次升高，完整性和一致性逐渐提高，但是并发性能逐渐降低。MySQL默认选择可重复读取，Oracle默认选择授权读取。由于脏读不可容忍而且需要一定的并发性能，因此一般不会选择未授权读取和序列化。</description>
    </item>
    
    <item>
      <title>JDBC基础五之JDBCUtil工具类示例</title>
      <link>https://rrrwx.github.io/2020/jdbc%E5%9F%BA%E7%A1%80%E4%BA%94jdbcutil%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Thu, 21 May 2020 19:57:24 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jdbc%E5%9F%BA%E7%A1%80%E4%BA%94jdbcutil%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%A4%BA%E4%BE%8B/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
为了更方便地使用JDBC来连接各种数据库，可以将数据库的连接与释放操作封装成一个工具类
import java.sql.Connection ; import java.sql.DriverManager ; public class JDBCUtil { //加载JDBCUtil类的时候只执行一次，不用每次连接的时候都加载配置文件和驱动类  public static Properties props = null ; static { try { //加载配置文件（不同的数据库有不同的配置文件）  //dbconfig.properties文件通常放在src目录下，也即ClassPath下  InputStream in = JDBCUtil.class.getClassLoader() .getResourceAsStream(&amp;#34;dbconfig.properties&amp;#34;) ; Properties props = new Properties() ; props.load(in) ; } catch (IOException e) { throw new RuntimeException(e) ; } try { //加载驱动类  Class.forName(props.getProperty(&amp;#34;driverClassName&amp;#34;)) ; } catch (ClassNotFoundException e) { throw new RuntimeException(e) ; } } public static Connection getConnection() throws SQLException { //获取Connection  return DriverManager.</description>
    </item>
    
    <item>
      <title>JDBC基础三之PreparedStatement</title>
      <link>https://rrrwx.github.io/2020/jdbc%E5%9F%BA%E7%A1%80%E4%B8%89preparedstatement/</link>
      <pubDate>Thu, 21 May 2020 16:12:49 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jdbc%E5%9F%BA%E7%A1%80%E4%B8%89preparedstatement/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
PreparedStatement接口  Statement接口的子接口 防SQL攻击 提高代码可读性、可维护性 提高效率  SQL攻击  在需要用户输入的地方，用户输入的是SQL语句的片段，最终用户输入的SQL片段与DAO中所写的SQL语句合成一个完整的SQL语句！
 演示 （1）首先创建一张用户表，用来存储用户的信息 CREATE TABLE user ( uid CHAR(32) PRIMARY KEY, username VARCHAR(30) UNIQUE KEY NOT NULL, PASSWORD VARCHAR(30) ); -- 这里的PASSWORD和mysql的关键词重名了，因此需要大写，也可以写成`password`  INSERT INTO user VALUES(&amp;#39;zhangSan&amp;#39;, &amp;#39;123&amp;#39;) ; INSERT INTO user VALUES(&amp;#39;liSi&amp;#39;, &amp;#39;123&amp;#39;) ; INSERT INTO user VALUES(&amp;#39;wangWu&amp;#39;, &amp;#39;123&amp;#39;) ; （2）使用username和password去查询数据 import java.sql.Connection ; import java.sql.DriverManager ; public class Demo { /** * 使用username和password去查询数据 * 若查到结果集，说明正确，返回true * 若查不到结果，则说明用户名或密码错误，返回false */ public boolean login throws Exception (String username, String password) { //准备四大参数  String driverClassName = &amp;#34;com.</description>
    </item>
    
    <item>
      <title>JDBC基础二之结果集</title>
      <link>https://rrrwx.github.io/2020/jdbc%E5%9F%BA%E7%A1%80%E4%BA%8C%E7%BB%93%E6%9E%9C%E9%9B%86/</link>
      <pubDate>Thu, 21 May 2020 12:18:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jdbc%E5%9F%BA%E7%A1%80%E4%BA%8C%E7%BB%93%E6%9E%9C%E9%9B%86/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
结果集  1. ResultSet ResultSet表示结果集，它是一个二维表格。ResultSet内部维护一个行光标（游标Cursor），ResultSet提供了一系列的方法来移动游标（光标是**从1开始，mysql默认都能使用）：
 void beforeFirst(): 把光标放到第一行的上面，也是光标的默认位置； void afterLast(): 最后一行记录的下面； boolean first() boolean last() boolean isBeforeFirst() boolean isAfterLast() boolean isFirst() boolean isLast() boolean previous() boolean next() boolean relative(int row): 相对位移，当row为正数时，表示向下移动row行，负数则向上移动； boolean absolute(int row): 绝对位移，把光标移动到第row行； int getRow(): 返回当前光标所在行；  2. 获取结果集数据 如果已经知道当前列的数据类型就可以使用相应的get方法获取当前列数据，否则就用getObject()或者getString()
可以通过列名或者列的索引来指定当前列，其中列索引是从1开始，而不是0
 String getString(String columnName) String getString(int columnIndex) int getInt(String columnName) double getDouble(String columnName) boolean getBoolean(String columnName) Object getObject(String columnName)  3. 获取结果集元数据  得到元数据：rs.getMetaData()，返回值ResultSetMetaData(); 获取结果集列数：int getColumnCount(); 获取指定列的列名：String getColumnName(int countIndex);  int count = rs.</description>
    </item>
    
    <item>
      <title>JDBC基础一之连接数据库</title>
      <link>https://rrrwx.github.io/2020/jdbc%E5%9F%BA%E7%A1%80%E4%B8%80%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 21 May 2020 10:37:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jdbc%E5%9F%BA%E7%A1%80%E4%B8%80%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
什么是JDBC？ CRUD（C-create, R-read, U-update, D-delete）
参考： https://blog.csdn.net/jungle_rao/article/details/81274720
https://blog.csdn.net/jungle_rao/article/details/81274720
 JDBC（Java DataBase Connectivity）是Java和数据库之间的一个桥梁，是一个规范而不是一个实现，能够执行SQL语句。它由一组用Java语言编写的类和接口组成。各种不同类型的数据库都有相应的实现。
  Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。JDBC也是Sun Microsystems的商标。我们通常说的JDBC是面向关系型数据库的。
 JDBC连接数据库 1. 连接的四大参数 driverName、url、username、password import java.sql.Connection ; import java.sql.DriverManager ; public class DBUtil { // jdbc协议的格式：jdbc:厂商的名称:子协议(有厂商自己来规定)  // mysql子协议：//主机:端口号/数据库名称 	public static final String URL = &amp;#34;jdbc:mysql://localhost:3306/mydb000&amp;#34; ; public static final String USERNAME = &amp;#34;root&amp;#34; ; public static final String PASSWORD = &amp;#34;123&amp;#34; ; public void fun1() throws ClassNotFoundException, SQLException { /* * jdbc的四大配置参数（例） * &amp;gt; driverClassName: com.</description>
    </item>
    
    <item>
      <title>mysql学习系列之建表脚本</title>
      <link>https://rrrwx.github.io/2020/%E5%BB%BA%E8%A1%A8%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Wed, 20 May 2020 00:18:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E5%BB%BA%E8%A1%A8%E8%84%9A%E6%9C%AC/</guid>
      <description>所有的mysql学习系列文章中的示例表格都是基于下面的建表脚本构造的
建表 use mydb000; drop table if exists emp; create table if not exists dept( deptno int primary key, dname varchar(50), loc varchar(50) ); create table if not exists emp( empno int primary key, ename varchar(50), job varchar(50), mgr int, hiredate date, sal decimal(7,2), COMM decimal(7,2), deptno int, constraint fk_emp foreign key(mgr) references emp(empno), constraint fk_emp_dept foreign key(deptno) references dept(deptno) ); create table if not exists salgrade( grade int primary key, losal int, hisal int ) ; create table if not exists stu ( sid int primary key, sname varchar(50), age int, gender varchar(10), province varchar(50), tuition int ) ; 插入数据 insert into dept values ( 10, &amp;#39;教研部&amp;#39;, &amp;#39;北京&amp;#39; ), ( 20, &amp;#39;学工部&amp;#39;, &amp;#39;上海&amp;#39; ), ( 30, &amp;#39;销售部&amp;#39;, &amp;#39;广州&amp;#39; ), ( 40, &amp;#39;财务部&amp;#39;, &amp;#39;武汉&amp;#39; ) ; select * from dept ; insert into emp values( 1009, &amp;#39;曾阿牛&amp;#39;, &amp;#39;董事长&amp;#39;, null, &amp;#39;2001-11-17&amp;#39;, 50000, null, 10 ), ( 1004, &amp;#39;刘备&amp;#39;, &amp;#39;经理&amp;#39;, 1009, &amp;#39;2001-04-02&amp;#39;, 29750, null, 20 ), ( 1006, &amp;#39;关羽&amp;#39;, &amp;#39;经理&amp;#39;, 1009, &amp;#39;2001-05-01&amp;#39;, 28500, null, 30 ), ( 1007, &amp;#39;张飞&amp;#39;, &amp;#39;经理&amp;#39;, 1009, &amp;#39;2001-09-01&amp;#39;, 24500, null, 10 ), ( 1008, &amp;#39;诸葛亮&amp;#39;, &amp;#39;分析师&amp;#39;, 1009, &amp;#39;2001-04-19&amp;#39;, 30000, null, 20 ), ( 1013, &amp;#39;庞统&amp;#39;, &amp;#39;分析师&amp;#39;, 1004, &amp;#39;2001-12-03&amp;#39;, 30000, null, 20 ), ( 1002, &amp;#39;黛绮丝&amp;#39;, &amp;#39;销售员&amp;#39;, 1006, &amp;#39;2001-02-20&amp;#39;, 16000, 3000, 30 ), ( 1003, &amp;#39;殷天正&amp;#39;, &amp;#39;销售员&amp;#39;, 1006, &amp;#39;2001-02-22&amp;#39;, 12500, 5000, 30 ), ( 1005, &amp;#39;谢逊&amp;#39;, &amp;#39;销售员&amp;#39;, 1006, &amp;#39;2001-09-28&amp;#39;, 12500, 14000, 30 ), ( 1010, &amp;#39;韦一笑&amp;#39;, &amp;#39;销售员&amp;#39;, 1006, &amp;#39;2001-09-08&amp;#39;, 15000, 0, 30 ), ( 1012, &amp;#39;程普&amp;#39;, &amp;#39;文员&amp;#39;, 1006, &amp;#39;2001-12-03&amp;#39;, 9500, null, 30 ), ( 1014, &amp;#39;黄盖&amp;#39;, &amp;#39;文员&amp;#39;, 1007, &amp;#39;2002-01-23&amp;#39;, 13000, null, 10 ), ( 1011, &amp;#39;周泰&amp;#39;, &amp;#39;文员&amp;#39;, 1008, &amp;#39;2007-05-23&amp;#39;, 11000, null, 20 ), ( 1001, &amp;#39;甘宁&amp;#39;, &amp;#39;文员&amp;#39;, 1013, &amp;#39;2000-12-17&amp;#39;, 8000, null, 20 ), ( &amp;#39;1015&amp;#39;, &amp;#39;张三&amp;#39;,&amp;#39;保洁员&amp;#39;,&amp;#39;1001&amp;#39;,&amp;#39;2008-03-04&amp;#39;,80000,10000,10 ); select * from emp ; insert into salgrade values( 1, 7000, 12000 ), ( 2, 12010, 14000 ), ( 3, 14010, 20000 ), ( 4, 20010, 30000 ), ( 5, 30010, 99990 ) ; select * from salgrade ; </description>
    </item>
    
    <item>
      <title>排序</title>
      <link>https://rrrwx.github.io/2020/%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 19 May 2020 00:20:18 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E6%8E%92%E5%BA%8F/</guid>
      <description>复杂度比较    排序方法 最好时间复杂度 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定     直接插入排序 O(n) O(n2) O(n2) O(1) 是   冒泡排序 O(n) O(n2) O(n2) O(1) 是   简单选择排序 O(n2) O(n2) O(n2) O(1) 否   希尔排序    O(1) 否   快速排序 O(nlogn) O(nlogn) O(n2) O(logn) 否   堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 否   二路归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 是   基数排序  O(d(n+r))  O(n) 是     适用条件 n&amp;lt;100: 直插、冒泡、简单选择</description>
    </item>
    
    <item>
      <title>红黑树</title>
      <link>https://rrrwx.github.io/2020/%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
      <pubDate>Tue, 19 May 2020 00:20:12 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
      <description>红黑树 https://blog.csdn.net/v_JULY_v/article/details/6105630
 红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。
 （1）红黑树的5条基本性质：  1）每个结点要么是红的，要么是黑的。
2）根结点是黑的。
3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
4）如果一个结点是红的，那么它的俩个儿子都是黑的。
5）对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。
  红黑树只是保持相对平衡： 若H(left)&amp;gt;=H(right)，则：H(left)&amp;lt;=2*H(right)+1，但BH(left)===BH(right)，H(left)&amp;lt;H(right)同理
 （2）红黑树的插入平衡调整 https://zhuanlan.zhihu.com/p/52706646 https://www.bilibili.com/video/av23890827?p=11
插入原则：
插入例图：
插入的结点是x（初始化为红色），或者说是上一步刚调整完的子树是x
这里case1调整完之后，结点G的黑高是改变了的，而且颜色也变成了红色，因此还需要进一步向上回溯，知道最终的平衡。
AVL树和红黑树的性能比较：
（3）红黑树的删除调整 删除原则：
删除例图：
无需进行删除调整的情况是：
 若需删除的结点X是红色的，直接删除X
另外，1）当前结点X为根节点，直接染黑，rootOver； 2）当前结点为红色，直接染黑，redOver；
 删除设定：
删除的几种情况的转换：
AVL树和RBT树的删除性能比较：</description>
    </item>
    
    <item>
      <title>ffmpeg常用命令</title>
      <link>https://rrrwx.github.io/2020/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 19 May 2020 00:19:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>记录一下经常用到的ffmpeg使用方法、hevc官方软件HM的使用，以及shell脚本的配套使用 另外，对于ffmpeg的参数设置可以参考 https://blog.csdn.net/hemingwang0902/article/details/4382205 https://www.jianshu.com/p/a035056cbbf9
具体比较详细的应用可以参考 https://www.jianshu.com/p/b4f9f8c5e86a https://zhuanlan.zhihu.com/p/46903150
（一） ffmpeg的常用操作 1. 使用ffmpeg把jpg格式的图片转换成yuv420p格式
ffmpeg -i path/name.jpg -s 352x288 -pix_fmt yuv420p savepath/name.yuv -s 352x288是图片的width和height参数，可以省略 -pix_fmt yuv420p是指定要转换的yuv的格式，若想转换成yuv422p格式的话直接替换就行
2. 使用ffmpeg把yuv格式的图片转换成jpg格式
ffmpeg -s 352x288 -pix_fmt yuv420p -i path/name.yuv -pix_fmt rgb24 savepath/name.jpg 这里的格式是转换成rgb24位。若想要存成png格式，改变要保存的图片的后缀即可
3. 使用ffmpeg把MP4格式的视频转换成yuv格式
ffmpeg -i path/name.avi -c:v rawvideo -pix_fmt yuv420p path/name.yuv -video_size 320x480 这里-c:v和-vcodec是等价的
4. 把yuv格式的视频转换成avi格式
ffmpeg -s 320x480 -i path/name.yuv -vcodec copy path/name.avi -s设置视频的长宽参数，copy表示copy表示原始编解码数据必须被拷贝，转换前后视频的大小不变，也可以换成mpeg4等编码格式
5. ffmpeg将一个视频切成多张图片
ffmpeg -i path/name.avi savepath/Frame%3d.png 6. ffmpeg将多张图片合成一个视频
ffmpeg -r 30 -i path/Frame%3d.</description>
    </item>
    
    <item>
      <title>常见字符编码方式比较</title>
      <link>https://rrrwx.github.io/2020/%E5%B8%B8%E8%A7%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</link>
      <pubDate>Mon, 18 May 2020 13:30:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E5%B8%B8%E8%A7%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83/</guid>
      <description>1. ASCII编码 作用：表语英语及西欧语言。
位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。
范围：ASCII从00到7F，扩展从00到FF。
2. Iso8859-1编码 属于单字节编码，最多能表示的字符范围是0-255，应用于英文系列。
作用：扩展ASCII，表示西欧、希腊语等。
位数：8位，
范围：从00到FF，兼容ASCII字符集。
3. GB码字符集 （1）GB码字符集
 全称是GB2312-80《信息交换用汉字编码字符集基本集》，1980年发布，是中文信息处理的国家标准，在大陆及海外使用简体中文的地区（如新加坡 等）是强制使用的唯一中文编码。P-Windows3.2和苹果OS就是以GB2312为基本汉字编码， Windows 95/98则以GBK为基本汉字编码、但兼容支持GB2312。
  双字节编码
范围：A1A1~FEFE
A1-A9：符号区，包含682个符号
B0-F7：汉字区，包含6763个汉字
 （2）GB2312字符集
 GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从 A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。GB2312-80中共收录了7545个字符，用两个字节编码一个 字符。每个字符最高位为0。GB2312-80编码简称国标码 。
GB2312支持的汉字太少。1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。
 作用：国家简体中文字符集，兼容ASCII。
位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。
范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码。
（3）GB12345-90字符集
 1990年制定了繁体字的编码标准GB12345-90《信息交换用汉字编码字符集第一辅助集》，目的在于规范必须使用繁体字的各种场合，以及古籍整理 等。该标准共收录6866个汉字（比GB2312多103个字，其它厂商的字库大多不包括这些字），纯繁体的字大概有2200余个。
  双字节编码
范围：A1A1~FEFE
A1-A9：符号区，增加竖排符号
B0-F9：汉字区，包含6866个汉字
 （4）GBK
 GBK编码(Chinese Internal Code Specification)是中国大陆制订的、等同于UCS的新的中文编码扩展国家标准。gbk编码能够用来同时表示==繁体字和简体字==，而gb2312只 能表示简体字，gbk是兼容gb2312编码的。GBK工作小组于1995年10月，同年12月完成GBK规范。该编码标准兼容GB2312，共收录汉字 21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。Windows95/98简体中文版的字库表层编码就采用的是GBK，通过 GBK与UCS之间一一对应的码表与底层字库联系。
  英文名：Chinese Internal Code Specification
中文名：汉字内码扩展规范1.0版
双字节编码，GB2312-80的扩充，在码位上和GB2312-80兼容
范围：8140~FEFE（剔除xx7F）共23940个码位。包含21003个汉字，包含了ISO/IEC 10646-1中的全部中日韩汉字
 ​	作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。</description>
    </item>
    
    <item>
      <title>数据库介绍</title>
      <link>https://rrrwx.github.io/2020/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Sat, 16 May 2020 21:10:41 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>源自：https://www.runoob.com/mysql/mysql-tutorial.html
https://my.oschina.net/u/3647687/blog/1534979
MySQL是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。
什么是数据库？ 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。
每个数据库都有一个或多个不同的 API 用于创建，访问，管理，搜索和复制所保存的数据。
我们也可以将数据存储在文件中，但是在文件中读写数据速度相对较慢。
所以，现在我们使用关系型数据库管理系统（RDBMS）来存储和管理大数据量。所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。
RDBMS 即关系数据库管理系统(Relational Database Management System)的特点：
 1.数据以表格的形式出现 2.每行为各种记录名称 3.每列为记录名称所对应的数据域 4.许多的行和列组成一张表单 5.若干的表单组成database   RDBMS 术语 在我们开始学习MySQL 数据库前，让我们先了解下RDBMS的一些术语：
 数据库： 数据库是一些关联表的集合。 数据表： 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列： 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据。 行： 一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余： 存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键： 主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键： 外键用于关联两个表。 复合键： 复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引： 使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性： 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。  MySQL 为关系型数据库(Relational Database Management System), 这种所谓的&amp;quot;关系型&amp;quot;可以理解为&amp;quot;表格&amp;quot;的概念, 一个关系型数据库由一个或数个表格组成, 如图所示的一个表格:
 表头(header)： 每一列的名称; 列(col)： 具有相同数据类型的数据的集合; 行(row)： 每一行用来描述某条记录的具体信息; 值(value)： 行的具体信息, 每个值必须与该列的数据类型相同; 键(key)： 键的值在当前列中具有唯一性。   MySQL数据库 MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</description>
    </item>
    
    <item>
      <title>mysql基本操作</title>
      <link>https://rrrwx.github.io/2020/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 16 May 2020 20:00:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
（一）服务器操作  开启服务器： net start mysql 关闭服务器： net stop mysql  （二）客户端操作   登录服务器：mysql -uroot -p123 -hlocalhost
 -u: 用户名 -p: 密码 -h: ip地址    退出服务器：exit或quit
  （三）备份与恢复数据库   数据库 &amp;lt;====&amp;gt; SQL语句
  数据库导出SQL副本（备份数据库内容而不是整个数据库）：
 mysqldump -u 用户名 -p 密码 数据库名&amp;gt;脚本存储路径 注意： 这里没有登录mysql，是在cmd环境下执行的，因此不用加分号； 生成的脚本文件里面是不包含create database语句的，因此这里备份的是数据库内容而非整个数据库；    执行SQL脚本
 方法一  mysql -u 用户名 -p 密码 数据库名&amp;lt;脚本存储路径 这里同样没有登录mysql，而且是在cmd环境下执行的，因此不用加分号；   方法二  source SQL脚本存储路径; 注意 ：这里需要先登录mysql，进入需要的数据库之后再执行；      --例： --首先导出SQL脚本文件（在cmd环境下执行） mysqldump -u root -p 000 mydb0&amp;gt;/usrs/name/mydb0.</description>
    </item>
    
    <item>
      <title>SQL语法之多表查询</title>
      <link>https://rrrwx.github.io/2020/%E4%BA%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 16 May 2020 10:30:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E4%BA%8C%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
多表查询 分类 （一）合并结果集（了解）  要求被合并的表中，列的类型和列数相同 UNION：去重 UNION ALL：不去重  create table ab (a int, b varchar(50)); insert into ab values (1, &amp;#39;1&amp;#39;); insert into ab values (2, &amp;#39;2&amp;#39;); insert into ab values (3, &amp;#39;3&amp;#39;); create table cd (c int, d varchar(50)); insert into cd values (3, &amp;#39;3&amp;#39;); insert into cd values (4, &amp;#39;4&amp;#39;); insert into cd values (5, &amp;#39;5&amp;#39;); select * from ab union [all] select * from cd ; （二）连接查询 1.</description>
    </item>
    
    <item>
      <title>SQL语法之约束</title>
      <link>https://rrrwx.github.io/2020/%E4%B8%80%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Sat, 16 May 2020 08:30:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E4%B8%80%E7%BA%A6%E6%9D%9F/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
约束 约束是使用在列上，用于约束列的
参考 https://blog.csdn.net/f45056231p/article/details/81070437
主键、外键和索引的区别？
    主键 外键 索引     定义： 唯一标识一条记录，不能有重复的，不允许为空 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 该字段没有重复值，但可以有一个空值   作用： 用来保证数据完整性 用来和其他表建立联系用的 是提高查询排序的速度   个数： 主键只能有一个 一个表可以有多个外键 一个表可以有多个惟一索引    1. 主键约束（唯一标识）  关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键
  特点：唯一、非空、可引用  -- 设置主键 -- 方法一 create table stu ( sid int primary key, name varchar(50), age int ) ; -- 方法二 create table stu ( sid int, name varchar(50), age int, primary key (sid) ); -- 方法三 alter table stu add primary key(sid); -- 删除主键 alter table stu drop primary key; 2.</description>
    </item>
    
    <item>
      <title>SQL语法之DQL</title>
      <link>https://rrrwx.github.io/2020/dql%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Fri, 15 May 2020 19:30:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/dql%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
DQL（Data Query Language） 数据查询语言，用来查询数据。
一、基本查询 1. 字段（列）查询 1）查询所有列  SELECT * FROM 表名；  2）查询指定列  SELECT 列名1 [, 列名2, &amp;hellip;] FROM 表名；  3）查询不重复记录  当查询结果中有多行记录一模一样时，只显示一行。一般在只查询一列或数列时会出现这种情况； SELECT DISTINCT* | 列名1 [, 列名2, &amp;hellip;] FROM 表名；  4) 列运算   I 数量类型的列可以做加、减、乘、除运算：
 SELECT sal*1.5 FROM emp ; SELECT sal+comm FROM emp ;    II 字符串类型可以做连续运算：
 SELECT CONCAT(&amp;lsquo;$&amp;rsquo;, sal) FROM emp ; 只能使用CONCAT来连接字符串；    III 转换NULL值：</description>
    </item>
    
    <item>
      <title>SQL语法之DML</title>
      <link>https://rrrwx.github.io/2020/dml%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Fri, 15 May 2020 17:30:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/dml%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
DML（Data Manipulation Language） 数据操作语言，用来定义数据库记录（数据）
增删改：表记录；
1. 插入数据   INSERT INTO 表名 (列名1, 列名2, &amp;hellip;) VALUES (列值1, 列值2, &amp;hellip;) [, (列值1, 列值2, &amp;hellip;), &amp;hellip;]；
 在表名后面给出要插入的列名，其他没有指定的列等同于插入null值； 在VALUES后面给出列值，值得顺序和个数与前面指定的列名对应； 例：INSERT INTO stu (number, name, age, gender) VALUES (&amp;lsquo;ITCAST_0001&amp;rsquo;, &amp;lsquo;jade&amp;rsquo;, 22, &amp;lsquo;m&amp;rsquo;);    INSERT INTO 表名 VALUES(列值1, 列值2)
 没有给出列名则说明要插入所有列； 列值的顺序与个数与表创建时给出的列顺序相同；    2. 修改数据  UPDATE 表名 SET 列名1=列值1, 列名2=列值2, 。。。 [WHERE 条件]；  条件（可选）：  条件必须是boolean类型的值或表达式； 运算符：=, !</description>
    </item>
    
    <item>
      <title>SQL语法之DDL</title>
      <link>https://rrrwx.github.io/2020/ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Fri, 15 May 2020 14:30:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/ddl%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
DDL （Data Definition Language） 数据定义语言，用于定义数据库对象：库、表、列等
创建、删除、修改：库、表的结构；
1. 操作数据库  查看所有数据库：SHOW DATABASES 切换（选择要操作的）数据库：USE 数据库名 创建数据库：CREATE DATABASE [IF NOT EXISTS] 数据库名 [CHARSET=utf8] 删除数据库：DROP DATABASE [IF EXISTS] 数据库名 修改数据库编码：ALTER DATABASE 数据库名 CHARACTER SET utf8  2. 常用数据类型（列）   int：整型；
  double：浮点型，如double(5,2)表示最多5位，其中必须有2位小数，即最大值999.99；
  decimal：浮点型，在表达钱方面使用，不会出现精度确实问题；
  char：固定长度字符串类型，如char(255)，数据长度不足指定长度会补足到制定长度；
  varchar：可变长度字符串类型（需要至少1B来记录长度），如varchar(65535)：zhangSan；
  text(clob&amp;ndash;官方)：字符串类型 &amp;mdash; mysql方言；
分4种大小的；
  blob：字节类型；
也是分4种大小；
  date：日期类型，格式为：yyyy-MM-dd；
  time：时间类型，格式为：hh: mm: ss；
  timestamp：时间戳类型（日期+时间）；</description>
    </item>
    
    <item>
      <title>SQL语法之DCL</title>
      <link>https://rrrwx.github.io/2020/dcl%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Fri, 15 May 2020 13:30:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/dcl%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
DCL（Data Control Language） 数据控制语言，用来定义用户的创建以及访问权限和安全级别；
  一个项目创建一个用户，一个项目对应的数据库只有一个;
  这个用户只对这个数据库有权限，其他数据库操作不了；
  1. 创建用户  CREATE USER 用户名@IP地址IDENTIFIED BY &amp;lsquo;密码&amp;rsquo;；  为用户指定登录的IP地址，则该用户只能在该IP上登录；   CREATE USER 用户名@&amp;rsquo;%&amp;lsquo;IDENTIFIED BY &amp;lsquo;密码&amp;rsquo;；  用户可以在任意IP地址登录；    2. 给用户授权  GRANT权限1, 权限2, &amp;hellip; ON 数据库.* TO用户名@IP地址  权限、用户、数据库； 给用户分派在指定的数据库上的指定权限； 例如：GRANT CREATE, ALTER, DROP, INSERT UPDATE, DELETE, SELECT ON mydb000.* TO user@localhost；   GRANT ALL ON mydb000.* TO user@localhost;  给指定用户分派该数据库上的所有权限；    3.</description>
    </item>
    
    <item>
      <title>SQL语法</title>
      <link>https://rrrwx.github.io/2020/sql%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Fri, 15 May 2020 08:30:48 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/sql%E8%AF%AD%E6%B3%95/</guid>
      <description>https://edu.aliyun.com/roadmap/java?spm=a2c6h.12999620.1371257.1.5a195738ZJjjex#part1
SQL语法 SQL（Structured Query Language）结构化查询语言
作用 客户端使用SQL来控制服务器
标准  可以单行或多行写，以分号结尾； 可使用空格和tab来增强语句的可读性； 不区分大小写，但建议大写； 由国际标准化组织（ISO）制定，对DBMS的统一操作方式（还有SQL方言：使用limit语句）  分类   DDL （Data Definition Language）：数据定义语言，用于定义数据库对象：库、表、列等
创建、删除、修改：库、表的结构 ；
  DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）
增删改：表记录；
  DCL（Data Control Language）：数据控制语言，用来定义用户的创建以及访问权限和安全级别；
  DQL（Data Query Language）：数据查询语言，用来查询数据。
  </description>
    </item>
    
    <item>
      <title>python爬虫笔记（六）</title>
      <link>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E5%85%AD/</link>
      <pubDate>Wed, 06 May 2020 00:23:18 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E5%85%AD/</guid>
      <description>（一）正则式表达 可参考 http://www.runoob.com/regexp/regexp-syntax.html
import re match = re.search(r&amp;#39;[1-9]\d{5}&amp;#39;, &amp;#39;BIT 200300&amp;#39;) # regex = re.compile(r&amp;#39;[1-9]\d{5}&amp;#39;) # match = regex.search(&amp;#39;BIT 200300&amp;#39;) if match: print(match.group(0)) for match in re.finditer(r&amp;#39;[1-9]\d{5}&amp;#39;, &amp;#39;BIT100081, TSU100084&amp;#39;): if match: print(match.group(0)) 200300 100081 100084 Re库默认使用贪婪匹配，即输出匹配长度最长的字符串
(二)Scrapy爬虫框架  Scrapy 是用 Python 实现的一个为了爬取网站数据、提取结构性数据而编写的应用框架。
Scrapy 常应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。
通常我们可以很简单的通过 Scrapy 框架实现一个爬虫，抓取指定网站的内容或图片。
 scrapy是使用命令行来爬取网站数据。首先建立一个工程项目，然后在spider目录下编写爬虫代码
$ scrapy startproject spiderdemo $ cd spiderdemo $ scrapy genspider demo python123.io 这样就可以在spider目录下看到demo.py，然后往里面添加爬虫需求即可。
# -*- coding: utf-8 -*- import scrapy class DemoSpider(scrapy.Spider): name = &amp;#34;demo&amp;#34; #allowed_domains = [&amp;#34;python123.</description>
    </item>
    
    <item>
      <title>python爬虫笔记（五）</title>
      <link>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E4%BA%94/</link>
      <pubDate>Tue, 05 May 2020 00:22:18 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E4%BA%94/</guid>
      <description>(一)BeautifulSoup库 Beautiful Soup是python的一个库，主要功能是从网页抓取数据，也叫beaultifulsoup4或bs4。
 Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。
 import requests r = requests.get(&amp;#34;https://python123.io/ws/demo.html&amp;#34;) demo = r.text from bs4 import BeautifulSoup soup = BeautifulSoup(demo, &amp;#34;html.parser&amp;#34;) print(soup.prettify()) &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt; This is a python demo page &amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;b&amp;gt; The demo python introduces several python courses. &amp;lt;/b&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p class=&amp;#34;course&amp;#34;&amp;gt; Python is a wonderful general-purpose programming language. You can learn Python from novice to professional by tracking the following courses: &amp;lt;a class=&amp;#34;py1&amp;#34; href=&amp;#34;http://www.</description>
    </item>
    
    <item>
      <title>python爬虫笔记（三）</title>
      <link>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
      <pubDate>Sun, 03 May 2020 00:21:18 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
      <description>爬虫实例 （一）更换用户代理 爬取时默认user-agent是 * python-requests/2.18.4 *
import requests def getHTMLText(url): try: r = requests.get(url, timeout=30) print(r.request.headers) r.raise_for_status() r.encoding = r.apparent_encoding return r.text[500:800] except: return &amp;#34;wrong connection...&amp;#34; if __name__ == &amp;#34;__main__&amp;#34;: this_url = &amp;#34;http://www.amazon.cn/gp/product/B01M8L5Z3Y&amp;#34; print(getHTMLText(this_url)) {&amp;#39;User-Agent&amp;#39;: &amp;#39;python-requests/2.18.4&amp;#39;, &amp;#39;Accept-Encoding&amp;#39;: &amp;#39;gzip, deflate&amp;#39;, &amp;#39;Accept&amp;#39;: &amp;#39;*/*&amp;#39;, &amp;#39;Connection&amp;#39;: &amp;#39;keep-alive&amp;#39;} {&amp;#39;user-agent&amp;#39;: &amp;#39;Mozilla/5.0&amp;#39;, &amp;#39;Accept-Encoding&amp;#39;: &amp;#39;gzip, deflate&amp;#39;, &amp;#39;Accept&amp;#39;: &amp;#39;*/*&amp;#39;, &amp;#39;Connection&amp;#39;: &amp;#39;keep-alive&amp;#39;} ue = {}; (function(d){var e=d.ue=d.ue||{},f=Date.now||function(){return+new Date};e.d=function(b){return f()-(b?0:d.ue_t0)};e.stub=function(b,a){if(!b[a]){var c=[];b[a]=function(){c.push([c.slice.call(arguments),e.d(),d.ue_id])};b[a].replay=function(b){for(var a;a=c.shift();)b(a[0],a[1],a[2])};b[a]. 有可能会被网站根据user-agent识别出是爬虫而不是普通用户，然后可以通过更改user-agent来爬取
kv = {&amp;#39;user-agent&amp;#39;:&amp;#39;Mozilla/5.0&amp;#39;} r = requests.get(url, headers = kv) print(r.</description>
    </item>
    
    <item>
      <title>python爬虫笔记（二）</title>
      <link>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Sat, 02 May 2020 00:20:18 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>网络爬虫引发的问题 1.网络爬虫尺寸 （1）爬取网页 小规模、数据量小、爬取速度不敏感&amp;mdash;&amp;mdash;Requests库
（2）爬取网站、系列网站 中规模、数据规模较大、爬取速度敏感&amp;mdash;&amp;mdash;-Scrapy库
（3）爬取全网 大规模、搜索引擎、爬取速度关键&amp;mdash;&amp;mdash;&amp;ndash;定制开发
2.法律风险、骚扰问题、隐私泄露 审查来源
Robots协议：Robots Exclusion Standard网络爬虫排除标准
​ 在网站根目录下的robots.txt文件
User-agent: *
Disallow: /</description>
    </item>
    
    <item>
      <title>python爬虫笔记（一）</title>
      <link>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Fri, 01 May 2020 00:19:18 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/python%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>http://www.icourse163.org/course/BIT-1001870001?tid=1001962001#/info
授课老师：嵩天
课程简介：“The website is the API.”网络爬虫逐渐成为自动获取网络信息的主要形式。
 Requests库的使用：
import requests r = requests.get(url) 构造一个向服务器请求资源的Request对象（大写）；
返回一个包含服务器资源的Response对象；
（1）Response对象的属性
 r.status_code(200表示连接成功)
r.text（url响应内容）
r.content（响应内容的二进制形式）
r.encoding（从头部预测的编码方式）
r.apparent_encoding（从内容分析的编码方式）
&amp;mdash;&amp;mdash;-r.encoding = r.apparent_encoding
 (2)通用框架
import requests def getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return &amp;#34;wrong connection...&amp;#34; if __name__ == &amp;#34;__main__&amp;#34;: this_url = &amp;#34;http://www.baidu.com&amp;#34; print(getHTMLText(this_url)) (3)Requests库的主要方法
requests.request() #---------基础方法 requests.get();
requests.head();
requests.post();
requests.put();
requests.patch();
requests.delete()</description>
    </item>
    
    <item>
      <title>JVM学习八之字节码指令</title>
      <link>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E5%85%AB%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Wed, 25 Mar 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E5%85%AB%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/</guid>
      <description> Java虚拟机的指令由一个字节长度（u1）、代表着某种特定操作含义的数字（操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（操作数，Operands）而构成。
Java虚拟机采用面向操作数栈而不是寄存器的架构，大多数指令都不包含操作数，只有一个操作码。
  大部分指令都没有支持byte、char、short、boolean类型。是因为编译器在编译期或运行期将byte、short类型直接带符号扩展(Sign-Extend)，对boolean、char类型零位扩展(Zero-Extend)。
因此在实际操作时都是使用相应的int类型作为运算类型。
 指令分为：
1、加载和存储指令 用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。
比如iload_, istore_, iconst_, wide等
2、运算指令 对两个操作数栈上的值进行某种特定运算，并重新存入到操作数栈顶。
如iadd, isub, idiv, imul, irem, ineg, ior, ishl, iinc, dcmog(比较)等
3、类型转换指令 将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显示类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。 如i2b, i2c, i2s等;
进行窄化类型转换的时候，可能导致转换结果产生不同的正负号（简单丢弃多出的高位）、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。
另外浮点值NaN会转换成整型的0。
4、对象创建与访问指令 类实例和数组的创建和操作使用不同的指令。
创建类实例：new；
创建数组：newarray、anewarray、multianewarray；
访问类字段和实例字段：getfield、getstatic等；
数组元素加载到操作数栈：iaload等；
操作数栈的值加载到数元素中：iastore等；
取数组长度：arraylength；
检查类实例类型：instanceof、checkcast。
5、操作数栈管理指令 直接操作操作数栈。
出栈：pop，pop2；
入栈：dup，dup2等；
交换：swap。
6、控制转移指令 让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的吓一跳继续执行指令。即修改PC寄存器的值。
条件分支：ifeq、iflt、ifnull、if_cmpeq等；
复合条件分支：tableswitch、lookupswitch；
无条件分支：goto、jsr、ret等。
7、方法调用和返回指令 invokevirtual调用对象的实例方法；
invokeinterface调用接口方法；
inokespecial调用需要特殊处理的方法，你如实例初始化方法、私有方法和父类方法等；
invokestatic调用类方法；
invokedynamic在运行时动态解析出调用点限定符所引用的方法，并执行该方法；
返回指令：return、ireturn等。
8、异常处理指令 显式抛出异常的操作（throw语句）都由athrow指令来实现。
9、同步指令 支持synchronized方法块的同步
Java虚拟机支持方法级的同步以及方法内部一段指令的同步。使用管程（Monitor）来支持。
使用monitorenter和moniterexit两条指令来支持synchronized关键字的语义。
 另外，为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可以处理所有的异常，目的就是用来执行monitorexit指令。
 </description>
    </item>
    
    <item>
      <title>JVM学习七之类文件结构</title>
      <link>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%B8%83%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 23 Mar 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%B8%83%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
      <description>类文件结构 https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html https://blog.csdn.net/A_zhenzhen/article/details/77977345
 Class文件是一组以8位字节为基础单位的二进制流。
 （一）魔数：0xCAFEBABE 用于校验 （二）版本号 （三）常量池： cp_info
（四）访问标记： 通过相加计算得到访问标记
access_flags
（五）类索引、父类索引、接口索引 （六）字段表：描述接口和类中声明的变量 field_info
（七）方法表 method_info
（八）属性表 attribute_info
虚拟机规范预定义的属性: </description>
    </item>
    
    <item>
      <title>JVM学习六之虚拟机性能监控与故障处理工具</title>
      <link>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E5%85%AD%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 22 Mar 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E5%85%AD%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>虚拟机性能监控与故障处理工具 https://www.cnblogs.com/chanshuyi/p/jvm_serial_15_jdk_monitor_command.html
1、jps：虚拟机进程状况工具 类似ps命令，可以查看虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID（Local Virtual Mechine Identifier， LVMID）
jps [ option ] [ hostid ] -m 主类接收的参数 -v 虚拟机接收的参数 -l 打印主类的全名 -q 省略主类的名称 2、jstat：虚拟机统计信息监视工具 在纯文本状态下监视虚拟机状态的变化。用的较多的就是-gcutil，关注已使用空间占总空间的百分比
jstat [ option vmid [interval[s|ms] [count]] ] #jstat -gcutil 2764 1000 10 #每秒执行一次，一共执行10次 3、jinfo：Java配置信息工具 实时查看和调整虚拟机的各项参数
jinfo [ option ] pid #jinfo -flag UseSerialGC 2764 #输出： -XX:-UseSerialGC #jinfo -flag [+/-]option pid #和参数设置-XX:[+/-]option作用一样 4、jmap：java内存印象工具 jmap用于生成堆转储快照（一般称为heapdump或dump）
jmap [ option ] vmid #jmap -dump:[live, ]format=b, file=&amp;lt;filename&amp;gt; vmid #这里的live子参数说明是否只dump出存活的对象 5、jhat：虚拟机堆转储快照分析工具 jhat与jmap搭配使用</description>
    </item>
    
    <item>
      <title>JVM学习五之内存分配与回收策略</title>
      <link>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%BA%94%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</link>
      <pubDate>Fri, 20 Mar 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%BA%94%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</guid>
      <description>（一）内存分配与回收策略 给对象分配内存、 回收分配给对象的内存
1、对象优先在Eden分配  通过-XX:+PrintGCDetails打印收集器日志
-XX:SurvivorRatio=8指定Eden区大小
-XX:+UseSerialGC使用指定的收集器（Serial+Serial Old）
 2、大对象直接进入老年代  大对象指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组。
通过-XX:PretenureSizeThreshold参数指定需要分配至老年代的对象大小阈值
 3、长期存活的对象将进入老年代  -XX:MaxTenuringThreshold
在Survivor区每熬过一次Minor GC，年龄Age就会加1，直到加到阈值就会被晋升到老年代
动态对象年龄判定：如果Survivor控件中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就会直接进入老年代，无需等到设置的阈值中要求的年龄。
 4、空间分配担保  在Minor GC之前，虚拟机需要先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立则确保Minor GC是安全的；如果不成立，则会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，则继续检查老年代最大可用空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试Minor GC，尽管是有风险的，如果小于，则要进行Full GC。
-XX:+HandlePromotionFailure
 （二）逃逸分析与栈内分配 参考： https://blog.csdn.net/qiyue683209/article/details/82961472
 通过逃逸分析来决定某些实例或者变量是否要在堆中进行分配，如果开启了逃逸分析，即可将这些变量直接在栈上进行分配，而非堆上进行分配。这些变量的指针可以被全局所引用，或者被其它线程所引用。
 </description>
    </item>
    
    <item>
      <title>JVM学习三之垃圾回收</title>
      <link>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%B8%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</link>
      <pubDate>Thu, 19 Mar 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%B8%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BB%A5%E5%8F%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</guid>
      <description>参考：https://www.jianshu.com/p/23f8249886c6
垃圾回收 （一）垃圾判断算法 1、引用计数法  引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的Stop-The-World的垃圾收集机制
 2、可达性分析算法  通过GC ROOT的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收（可作为GC ROOT的对象：虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象，本地方法栈中JNI引用的对象）
 （二）垃圾回收算法 1、标记-清除算法  标记-清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。清理掉的垃圾就变成未使用的内存区域，等待被再次使用。
问题：内存碎片、标记清除效率不高
 2、复制算法  复制算法（Copying）是在标记清除算法基础上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况。
问题：每次可用内存缩小一半
 3、标记-整理算法  标记-整理算法（Mark-Compact）标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。
问题：对内存变动更频繁，需要整理所有存活对象的引用地址，效率低于复制算法
 4、分代收集算法  分代收集算法（Generational Collection）融合了上述3种基础的算法思想，根据对象存活周期的不同将内存划分为几块。
（1）在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
（2）在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理算法或者标记-整理算法来进行回收。
 （三）垃圾收集器 1、Serial收集器  最基本，发展最悠久； 单线程垃圾收集器（“Stop The World”）； 桌面应用场景（因为虚拟机分配到的内存空间不大，用户停顿时间在毫秒级）；  2、ParNew收集器 实际上就是Serial收集器的多线程版本，使用多线程进行垃圾收集（多个垃圾GC线程）； 可与CMS收集器（Concurrent Mark Sweep）配合工作；
 这里引入“并行”和“并发”的区别：
“并行”：指多条垃圾收集进程并行工作，但此时用户线程仍处于等待状态；
“并发”：指用户进程和垃圾收集进程同时执行（但不一定是并行的，可能会交替执行），用户程序继续执行，垃圾收集进程运行于另一个CPU上。
 3、Paraller Scavenge收集器 （1）复制算法（新生代收集器） （2）多线程收集器 （3）达到可控制的吞吐量： -XX:MaxGCPauseMillis垃圾收集器最大停顿时间
-XX:GCTimeRatio吞吐量（倒数）大小：如果值设置为19，那允许的最大GC时间就占总时间的5%&amp;mdash;1/(1+19)
 吞吐量（Throughput）：CPU用于运行用户代码的时间与CPU总消耗时间的比值，即
吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）。</description>
    </item>
    
    <item>
      <title>JVM学习二之JMM与内存溢出异常</title>
      <link>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%BA%8Cjava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Wed, 18 Mar 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%BA%8Cjava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</guid>
      <description>Java内存区域与内存溢出异常 （一）HotSpot虚拟机对象探秘 1、对象的创建 （1）为对象分配内存 https://blog.csdn.net/hyman_c/article/details/103051359
1)指针碰撞 2）空闲列表 选择哪种分配方式由Java堆是否规整来决定，而Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能（Conpact过程）决定。
（2）线程安全性问题 1）对分配内存控件的动作进行同步处理；
2）把内存分配的动作按照线程划分在不同的空间之中，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。当前TLAB用完并分配新的TLAB时，也需要同步锁定。
（3）对象的结构 https://www.cnblogs.com/duanxz/p/4967042.html https://blog.csdn.net/justry_deng/article/details/88421943
1）Object Header（对象头）：  HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如:哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”；
对象头的另一部分是类型指针，即对象指向它的类元数据的指针，在虚拟机通过这个指针来确定这个对象是哪个类的实例。不同虚拟机可以能有不同的实现，可能查找对象的元数据信息并不一定要通过对象本身。
 2）InstanceData（实例数据）：  实例数据部分是对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序的影响。HostSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers),从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true(默认为true)，那么子类之中较窄的变量也可能会插入到父类变量之中。
 3）Padding（填充）：  起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍(1倍或者2倍)，因此，当对象实例数据部分没有对齐时，就需要通过对其填充来补全。
 （4）对象的访问定位  Java程序通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。
 句柄：reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体的地址信息
直接指针：reference中存储的直接就是对象地址
 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改；使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。
注：HotSpot使用的直接指针的方式进行对象访问的。
 </description>
    </item>
    
    <item>
      <title>JVM学习一之运行时数据区域</title>
      <link>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%B8%80%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Tue, 17 Mar 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%B8%80%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</guid>
      <description>Java内存区域与内存溢出异常 （一）运行时数据区域 可参考
https://www.zhihu.com/question/20097631 https://blog.csdn.net/TJtulong/article/details/89598598 https://www.cnblogs.com/chanshuyi/p/jvm_serial_00_why_learn_jvm.html
1、程序计数器（Program Counter Register）  （1）程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器；
（2）程序计数器处于线程独占区；
（3）如果线程执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。而如果是native方法，这个计数器的值则为空（Undefined）；
（4）此内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域；
 2、Java虚拟机栈（Java Virtual Machine Stack） 虚拟机栈描述的是java方法执行的动态内存模型。 栈帧（方法运行时的基本数据结构）
 每个方法执行，都会创建一个栈帧，伴随着方法从创建到执行完成。用于存储局部变量表，操作数栈，动态链接，方法出口等；
 局部变量表
 1）存放编译器可知的各种基本数据类型，引用类型，returnAddress类型。
2）局部变量表的内存空间在编译器完成分配，当进入一个方法时，这个方法需要在帧分配多少内存是固定的，在方法运行期间是不会改变局部变量表的大小。
3）大小：
StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度； OutOfMemoryError：如果蓄奴籍栈可以动态扩展（大部分都可以），而扩展时无法申请到足够的内存；
 3、本地方法栈（Native Method Stack） 本地方法栈于虚拟方法栈所发挥的作用时非常相似的
区别：本地方法栈为虚拟机执行native方法服务； 虚拟机栈为悉尼及执行Java方法服务；
4、Java堆（Java Heap） Java堆是Java虚拟机所管理的内存中最大的一块，被所有线程共享，在虚拟机启动时创建
 （1）目的：存放对象实例 ；
（2）垃圾收集器管理的主要区域（GC堆，Garbage Collected Heap）：新生代（Eden空间、From Survivor空间、To Survivor空间等）、老年代；另外，还可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）；
（3）OutOfMemoryError：堆中没有内存完成实例分配，并且堆也无法再扩展时抛出；
（4）不需要连续的内存空间，逻辑连续就行。
 5、方法区（Method Area）  （1）方法区是线程共享的内存区域，用于存储已被虚拟机加载的类信息（类的版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码等数据；
（2）HotSpot虚拟机上吧方法区成为“永久代”（Permanent Generation），本质上两者并不等价，只是能省去专门为方法区编写内存管理代码的工作；
（3）方法区的垃圾回收效率很低；
（4）OutOfMemoryError：和堆类似。
  （上面说到，jdk1.8 中，已经不存在永久代（方法区），替代它的一块空间叫做 “ 元空间 ”，和永久代类似，都是 JVM 规范对方法区的实现，但是元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制，但可以通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来指定元空间的大小。）</description>
    </item>
    
    <item>
      <title>JVM学习之一些重要的知识点</title>
      <link>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Tue, 17 Mar 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/jvm%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>https://www.cnblogs.com/chanshuyi/p/jvm_serial_04_from_source_code_to_machine_code.html
1、编译器和解释器，源代码到字节码再到机器码 JIT编译器（Just In Time Compiler）  当源代码转化为字节码之后，其实要运行程序，有两种选择。一种是使用 Java 解释器解释执行字节码，另一种则是使用 JIT 编译器将字节码转化为本地机器代码。
这两种方式的区别在于，前者启动速度快但运行速度慢，而后者启动速度慢但运行速度快。至于为什么会这样，其原因很简单。因为解释器不需要像 JIT 编译器一样，将所有字节码都转化为机器码，自然就少去了优化的时间。而当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。所以在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。
  在 JVM 中有三个非常重要的编译器，它们分别是：前端编译器、JIT 编译器、AOT 编译器。
前端编译器，最常见的就是我们的 javac 编译器，其将 Java 源代码编译为 Java 字节码文件。JIT 即时编译器，最常见的是 HotSpot 虚拟机中的 Client Compiler 和 Server Compiler，其将 Java 字节码编译为本地机器代码。而 AOT 编译器则能将源代码直接编译为本地机器码。这三种编译器的编译速度和编译质量如下：
编译速度上，解释执行 &amp;gt; AOT 编译器 &amp;gt; JIT 编译器。
编译质量上，JIT 编译器 &amp;gt; AOT 编译器 &amp;gt; 解释执行。
而在 JVM 中，通过这几种不同方式的配合，使得 JVM 的编译质量和运行速度达到最优的状态。
 2、字节码结构 https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html
3、类加载执行步骤  JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。</description>
    </item>
    
    <item>
      <title>java基础学习笔记多线程之线程创建</title>
      <link>https://rrrwx.github.io/2020/%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 17 Feb 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E7%BA%BF%E7%A8%8B/</guid>
      <description>参考
  &amp;mdash;Runnable Module java.base Package java.lang
@FunctionalInterface public interface Runnable (since jdk1.0)
public interface Runnable { public abstract void run(); }   &amp;mdash;Thread Module java.base Package java.lang
public class Thread extends Object implements Runnable (since jdk1.0)
  &amp;mdash;Callable Module java.base Package java.util.concurrent
@FunctionalInterface public interface Callable(since jdk1.5)
public interface Callable&amp;lt;V&amp;gt; { /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception; }  Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</description>
    </item>
    
    <item>
      <title>java基础学习笔记之小记</title>
      <link>https://rrrwx.github.io/2020/%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sun, 16 Feb 2020 00:18:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E5%B0%8F%E8%AE%B0/</guid>
      <description>想到什么，看到什么，就记什么 参考教程尚学堂、阿里云课堂等
1.比较comparator和comparable  Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。
Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。
两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。
 2.ArrayList和数组  ArrayList就是“动态数组”，也是一个对象。
创建一个ArrayList对象，该对象存放在堆内存中，且是一个内存连续的内存区域。
1、ArrayList是用数组实现的，这个数组的内存是连续的，不存在相邻元素之间还隔着其他内存。
2、索引ArrayList时，速度比原生数组慢是因为你要用get方法，这是一个“函数调用”，而数组直接用[ ]访问，相当于直接操作内存地址，速度当然比函数调用快。
 3.this和方法调用  java里面的this可以省略，因为编译器会自动加上。 java的方法里面不能再定义方法，不过可以定义类，在类里又可以定义新的方法。（python的函数里面可以定义函数）
 4.PATH和CLASSPATH区别  PATH：操作系统提供的路径配置，定义所有可执行文件的类加载路径；
CLASSPATH：由JRE提供的，用于定义java程序解释时类加载路径，可以用“CLASSPATH=路径”的命令形式来定义；
JVM -&amp;gt; CLASSPATH定义的路径 -&amp;gt; 加载字节码文件。
 5.java数据类型    数据类型 大小/位 表示的数值范围     long(长整型) 64 -2E63 ~ 2E63-1   int(整型) 32 -2147483648 ~ 21474483647   short(短整型) 16 -32768~32767   byte(位) 8 -128 ~ 127   char(字符) 16 0 ~ 65536   float(单精度) 32 -3.</description>
    </item>
    
    <item>
      <title>java正则表达式</title>
      <link>https://rrrwx.github.io/2020/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Sun, 16 Feb 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>JDK1.4之后正则默认被JDK所支持，并且提供java.util.regex开发包，同时String类也支持直接正则处理
 1.常用正则标记 （1）字符：匹配单个字符。 a：表示匹配字母a； \\：转义字符&amp;#34;\&amp;#34;； \t：转义字符&amp;#34;\t&amp;#34;； \n：转义字符&amp;#34;\n&amp;#34;； （2）一组字符：任意匹配里面的单个字符 [abc]：可能是字母a、b或c； [^abc]：不是字母a、b或c中的任意一个； [a-zA-Z]：全部字母中的任意一个； [0-9]：全部数字中的任意一个； （3）边界匹配：（JavaScript里面可能会用到） ^：一组正则的开始； $：一组正则的结束； （4）简写表达式：每一位出现的简写标记也只表示一位 .：任意一位字符； \d：任意一位数字，等价于.[0-9]； \D：非数字的任意字符，等价于.[^0-9]； \w：任意一位字母、数字、_，等价于.[a-zA-Z0-9]； \W：非字母、数字、_以外的任意字符，等价于.[^a-zA-Z0-9]； \s：任意的一位空格，例如&amp;#34;\n&amp;#34;、&amp;#34;\t&amp;#34;、&amp;#34; &amp;#34;； \s：空格以外的任意字符； （5）数量表示：匹配多位字符 ?：出现0次或1次； *：出现0次、1次或多次； +：出现1次或多次； {n}：出啊先n次； {n,}：出现n次及以上； {n,m}：出现n~m次； （6）逻辑表示：与、或、非 表达式A表达式B：表达式A后面紧跟着表达式B； 表达式A|表达式B：表达式A或表达式B； （表达式）：将多个表达式合成一个表示，作为一组出现； 2.String类对正则的支持 public boolean matches(String regex) //匹配指定正则表达式 public String replaceAll(String regex, String replacement) //替换指定正则的全部内容 public String replaceFirst(String regex, String replacement) //替换指定正则的首个内容 public String[] split(String regex) //按照指定正则全拆分 public String[] split(String regex, int limit) //按照指定的正则拆分为指定个数 3.java.util.regex包支持 该包中有两个核心的正则操作类：Pattern（正则模式）和Matcher（匹配）</description>
    </item>
    
    <item>
      <title>java基础学习笔记（二）</title>
      <link>https://rrrwx.github.io/2020/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Sat, 15 Feb 2020 00:15:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>12.字符编码 System.out.println(&amp;#34;系统默认编码：&amp;#34;+ System.getProperty(&amp;#34;file.encoding&amp;#34;);//获取本地系统默认编码 //系统默认编码：UTF-8 （从JDK1.9起）  ISO8859-1：一种国际通用的单字节编码，最多只能表示0~255的字符范围，主要在英文传输中使用；
GBK/GB2312：中文的国标编码，专门用来表示汉字，是双字节编码，如果在此编码器中出现了中文，则使用ISO8859-1编码。GBK可以表示简体中文和繁体中文，而GB2312只能表示简体中文，GBK兼容GBK2312；
UNICODE：十六进制编码，可以准确地表示出任何语言文字，此编码不兼容ISO8859-1编码；
UTF-8编码：由于UNICODE不支持ISO8859-1编码，而且占用空间较多，英文字母也需要双字节去编码，不便于存储和传输，于是产生了UTF编码。UTF兼容ISO8859-1编码，同时也可以用来表示所有语言字符，但是UTF编码是不定长的编码，每一个字符的长度从1~6个字节不等，一般在中文网页使用此编码，可以节省空间。
 13.String.intern() https://blog.csdn.net/tyyking/article/details/82496901
 new String都是在堆上创建字符串对象。当调用 intern() 方法时，编译器会将字符串添加到常量池中（stringTable维护），并返回指向该常量的引用。
JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。简单的说，就是往常量池放的东西变了：原来在常量池中找不到时，复制一个副本放到常量池，1.7后则是将在堆上的地址引用复制到常量池。
 //Q：下列程序的输出结果： String s1 = “abc”; String s2 = “abc”; System.out.println(s1 == s2); //A：true，均指向常量池中对象。  //Q：下列程序的输出结果： String s1 = new String(“abc”); String s2 = new String(“abc”); System.out.println(s1 == s2); //A：false，两个引用指向堆中的不同对象。  //Q：下列程序的输出结果： String s1 = “abc”; String s2 = “a”; String s3 = “bc”; String s4 = s2 + s3; System.</description>
    </item>
    
    <item>
      <title>java基础学习笔记（一）</title>
      <link>https://rrrwx.github.io/2020/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Sat, 15 Feb 2020 00:10:36 +0800</pubDate>
      
      <guid>https://rrrwx.github.io/2020/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>1.方法可变参数： int &amp;hellip; data (JDK1.5以后提供，相当于数组的变相应用)
int sum(int ... data){} sum(1,2,3); sum(new int [] {1,2,3}); 方法中可变参数只能定义在最后，并且只能定义一个
2.类在java中是一种引用数据类型； String类的实现都是通过数组的形式进行保存的，因此对于String内部的数据一定是无法改变的；另外在jdk1.8以前，使用char数组来保存，而jdk1.9以后都使用byte数组来保存 String类的比较应该使用equals (https://blog.csdn.net/barryhappy/article/details/6082823)； String.intern()可以将对象手动入池，但麻烦，因此直接赋值比构造方法更节省空间。
3.override（覆写）和overloading（重载）    区别 overloading（重载） override（覆写）     定义 方法名称相同，参数类型和个数不同 方法名称、参数类型及个数、返回值类型全部相同   权限 无权限要求 被子类覆写的方法不能拥有比父类更严格的访问控制权限   范围 发生在同一个类中 发生在继承关系类中     构造方法不能被继承，因此不能被覆写，但可以被重载； 父类方法定义private时，子类无法覆写该方法
4.this和super （1）this表示先从本类查找所需要的属性或者方法，弱国本类不存在则查找父类定义，而super表示不查找子类，直接查找父类； （2）this()调用的是本类构造，super调用的是父类构造，而且都必须放在构造方法的首行，所以不能同时出现； （3）this可以表示当前对象；
5.volatile和synchronized的区别 （1）volatile主要使用于属性上，而synchronized应用于方法和代码块上； （2）volatile无法描述同步的处理，只是一种直接内存的处理，避免了副本的操作，节约了复制变量副本和同步的时间，而synchronized是实现同步操作的关键字（同步的时候使用volatile的同时还是要使用synchronized）。
6.String和StringBuffer、StringBuilder  String类是字符串的首选类型，其最大特点是内容不允许修改，StringBuffer和StringBuilder类的内容允许修改
在开发中，大部分情况都优先考虑String类，只有在频繁修改字符串的操作上才会考虑使用StringBuffer和StringBuilder类。
 （1）StringBuffer是线程安全的
 StringBuffer是在jdk1.0版本中提供的，但是jdk1.5之后又提供了StringBuilder类，两个类的唯一区别在于：StringBuffer类中的方法使用了synchronized关键字定义，适合多线程并发访问时的同步操作，因此属于线程安全的方法；而StringBuilder类没有这样做，属于非线程安全的方法
 （2）字符串静态常量池
String str=&amp;#34;hello &amp;#34;+&amp;#34;java&amp;#34;+&amp;#34; world&amp;#34;; 这句程序的本质操作实际上是由StringBuffer来完成的，其中所有的“+”操作都变成“append”</description>
    </item>
    
  </channel>
</rss>